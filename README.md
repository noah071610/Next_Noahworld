<br/>

<div align=center><a href="https://github.com/noah071610/Next_NoahWorld"><img src="https://user-images.githubusercontent.com/74864925/120079497-12334a00-c0ef-11eb-9b73-28eaab517f1c.png"/></a></div>

# <div align=center>Noah world Blog</div>

#### <div align=center>Place to step up.</div>

<br/>

<div align=center>
<img src="https://travis-ci.org/joemccann/dillinger.svg?branch=master"/>&nbsp
  <img src="https://img.shields.io/github/stars/noah071610/Next_NoahWorld?style=social"/>&nbsp
  <img src="https://img.shields.io/github/watchers/noah071610/Next_NoahWorld?style=social"/>&nbsp
</div>

<br/>

<div width="300" align=center>
<img src="https://img.shields.io/badge/Photoshop-31A8FF?style=flat-square&logo=adobe-photoshop&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/HTML5-E34F26?style=flat-square&logo=HTML5&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/CSS3-1572B6?style=flat-square&logo=CSS3&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/SCSS-CC6699?style=flat-square&logo=Sass&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=flat-square&logo=JavaScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/TypeScript-3178C6?style=flat-square&logo=TypeScript&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/React-61DAFB?style=flat-square&logo=React&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Next.js-000000?style=flat-square&logo=Next-dot-js&logoColor=white"/><br/>
<img src="https://img.shields.io/badge/Redux-764ABC?style=flat-square&logo=Redux&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Redux_Saga-999999?style=flat-square&logo=Redux-Saga&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Emotion-DB7093?style=flat-square&logo=styled-components&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Antd-0170FE?style=flat-square&logo=Ant-design&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Node.js-339933?style=flat-square&logo=node-dot-js&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Express-000000?style=flat-square&logo=Express&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Passport-34E27A?style=flat-square&logo=Passport&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Google_Login-4285F4?style=flat-square&logo=Google-Cloud&logoColor=white"/><br/>
<img src="https://img.shields.io/badge/MySQL-4479A1?style=flat-square&logo=MySQL&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Babel-F9DC3E?style=flat-square&logo=Babel&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Webpack-8DD6F9?style=flat-square&logo=Webpack&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Amazon_AWS-232F3E?style=flat-square&logo=Amazon-AWS&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/Linux-FCC624?style=flat-square&logo=Linux&logoColor=white"/>&nbsp;
<img src="https://img.shields.io/badge/NGINX-009639?style=flat-square&logo=NGINX&logoColor=white"/>&nbsp;
</div>

<br/>

<div align=center>
  <a href="https://github.com/noah071610" target="_blank"><img src="https://image.flaticon.com/icons/png/24/25/25657.png"/></a>&nbsp;
  <a href="https://www.instagram.com/salmonchobab" target="_blank"><img src="https://image.flaticon.com/icons/png/24/1409/1409946.png"/></a>&nbsp;
  <a href="https://velog.io/@noah071610" target="_blank"><img width="24" src="https://api.faviconkit.com/velog.io/144"/></a>&nbsp;
  <a href="noah071610@naver.com"><img src="https://image.flaticon.com/icons/png/24/552/552486.png"/></a>&nbsp;
  <a href="https://velog.io/@noah071610" target="_blank"><img src="https://image.flaticon.com/icons/png/24/3135/3135715.png"/></a>&nbsp;
</div>

<br/><br/><br/><br/>

## About Noah World.

#### 무리하지않는 깔끔한 디자인을 목표로 개설한 개인 블로그.

<br/>

![jeshoots-com-pUAM5hPaCRI-unsplash](https://user-images.githubusercontent.com/74864925/120084019-e96b7e80-c107-11eb-8e42-d2e4acbc90d2.png)

<br/>

- **페이지 전반**

최신 글 상단 배치, 해시태그와 검색기능, 부문별 탑 게시글과 조회수 ,좋아요수 ,게시날짜를 공유합니다.

회원가입, 구글 로그인, 로그인 유지, 로그아웃, 비밀번호 변경, 회원탈퇴 등의 기능을 제공합니다.

- **이용자**

이용자는 게시글 작성은 불가능하나 좋아요 댓글 기능을 이용할 수 있습니다.

이용자는 아이콘 사진 변경과 비밀번호 변경, 회원탈퇴가 가능합니다.

이용자는 개인 프로필 부분에서 실시간으로 업데이트된 최근 본 게시글과 댓글을 조회 할 수 있습니다.

- **관리자**

관리자만 접근할 수 있는 어드민 페이지를 이용해 관리자만 게시글을 작성 수정 삭제 할 수 있습니다.

<br/>
<br/>

## Summary.

- 프로젝트 인원 : 장현수(Noah) 외 0명
- 프로젝트 기간 : 2021/02 ~ 2021/04
- 프로젝트 언어:

  - 영어 (전반적인 블로그)
  - 일본어 (한국어 강의 페이지)
  - 한국어 (포트폴리오 페이지)

<br/><br/>

## Overview.

<br/>

#### 📍 &nbsp; 회원가입및 로그인아웃, 비밀번호 변경, 탈퇴 외 로그인유지 기능 구현.

<br/>

#### 📍 &nbsp; 유저 아이콘을 위한 이미지 업로드와 이미지 Crop 기능을 구현.

```javascript
📁profile/CropImageModal.tsx

  const handleOk = useCallback(() => {
    //5. blob 객체와 user id를 활용해 서버에 요청하기위해 form을 만듭니다.
    const form = new FormData();
    form.append("image", blob!);
    form.append("id", String(user?.id));
    dispatch({
      type: ADD_ICON_REQUEST,
      data: form,
    });
    setIsModalVisible(false);
    setUrl("");
    setUpImg(null);
  }, []);

  ...

  const onSelectFile = (e: React.ChangeEvent<HTMLInputElement>) => {
    //1-1. React-crop 공식문서를 참조했습니다. 이미지를 로드해줍니다.
    if (e.target.files && e.target.files.length > 0) {
      const reader = new FileReader();
      reader.addEventListener("load", () => setUpImg(reader.result));
      reader.readAsDataURL(e.target.files[0]);
    }
  };

  const onLoad = useCallback((img) => {
    imgRef.current = img;
  }, []);

  useEffect(() => {
    //3. React-crop 공식문서를 참조했습니다. canvas에 자른 이미지를 표시하는 로직입니다.
    if (!completedCrop || !previewCanvasRef.current || !imgRef.current) {
      return;
    }
    const image: any = imgRef.current;
    const canvas: any = previewCanvasRef.current;

    ...

    );
    new Promise(() => {
      canvas.toBlob(
        //4. 자른 이미지를 Blob 객체로 바꿔 state에 저장합니다.
        (blob: Blob) => {
          setBlob(blob);
        },
        "image/png",
        1
      );
    });
  }, [completedCrop]);

  return (
    {/* 0. Icon 수정 (+ Crop Image)는 Modal창에서 일어나며 Modal은 Antd를 사용했습니다. */}
    <Modal title="Icon Upload 🖼️" visible={isModalVisible} onOk={handleOk} onCancel={handleCancel}>
      <h3>Set icon from Local storage</h3>
      {/* 1. Url을 이용해 아이콘을 업로드할지, file을 이용할지 선택합니다. */}
      <input
        style={{ marginBottom: "1.5rem" }}
        type="file"
        accept="image/*"
        disabled={url ? true : false}
        onChange={onSelectFile}
      />
      <h3>Set icon by using URL</h3>
      <Input
        disabled={upImg ? true : false}
        value={url}
        onChange={onChangeUrl}
        placeholder="https://"
      />

      {(url || upImg) && (
        <>
          {/* 2. 올린 이미지를 활용해 이미지를 자릅니다. */}
          <h3>Crop the image for icon size.</h3>
          <ReactCrop
            crossorigin="anonymous"

            ...

```

---

<br/>

#### 📍 &nbsp; multer를 사용해 이미지를 AWS-S3에 저장.

```javascript
📁server/routes/user.js

// 아이콘 이미지를 서버에서 업로드하는 과정.

const upload = multer({
  storage: multerS3({
    // AWS.S3에 이미지를 저장하는 과정입니다.
    s3: new AWS.S3(),
    bucket: "noahworld",
    key(req, file, cb) {
      cb(null, `original/${Date.now()}_${path.basename(file.originalname)}`);
    },
  }),
  limits: { fileSize: 20 * 1024 * 1024 },
});

router.post("/icon", upload.single("image"), async (req, res, next) => {
  //유저가 file을 업로드하는 방식으로 아이콘을 업데이트한 경우
  User.update(
    { icon: req.file.location.replace(/\/original\//, "/thumb/") },
    { where: { id: req.body.id } }
  );
  res.json(req.file.location.replace(/\/original\//, "/thumb/"));
});

router.post("/icon/url", async (req, res, next) => {
  //유저가 url을 이용하는 방식으로 아이콘을 업데이트한 경우
  User.update({ icon: req.body.url }, { where: { id: req.body.UserId } });
  res.json(req.body.url);
});

router.delete("/icon/:UserId", async (req, res, next) => {
  //유저가 아이콘을 삭제하는경우, 미리 저장되어있는 default 값으로 변경합니다.
  User.update(
    { icon: "/images/blog/default-user.png" },
    { where: { id: parseInt(req.params.UserId, 10) } }
  );
  res.send({ success: true });
});

```

---

<br/>

#### 📍 &nbsp; TOP 좋아요, 댓글, 조회수 게시물 그리고 해시태그를 메인페이지에 배치.

```javascript
📁server/routes/post.js

    ...

    const getAttributesFromPosts = await Post.findAll({
      order: [["createdAt", "DESC"]],
      attributes: ["id", "hit"],
      include: [
        {
          model: User,
          as: "PostLikers",
          attributes: ["id"],
        },
        {
          model: Comment,
          include: [
            {
              model: User,
              attributes: ["id"],
            },
          ],
        },
      ],
    }).then((result) =>
      result.map((v) => {
        //전체 포스트중 아이디,좋아요수,코멘트수,조회수 전체를 배열형태로 가져옵니다.
        return [v.id, v.PostLikers.length, v.Comments.length, v.hit];
      })
    );
    // 가져온 값을 원하는 값에 따라 미리 분류해둡니다.
    const getLikes = await getAttributesFromPosts.map((v, i) => {
      return v[1];
    });
    const getComments = await getAttributesFromPosts.map((v, i) => {
      return v[2];
    });
    const getViews = await getAttributesFromPosts.map((v, i) => {
      return v[3];
    });

    const mostCalculator = (arr, index) =>
      getAttributesFromPosts.filter((v) => {
        //배열중 최대값을 구하기 위해 아래의 값을 사용했습니다.
        // * find 메쏘드를 사용하면 배열이아닌 객체로 반환하는걸 알았습니다. 곧 수정하겠습니다. (2021/05/30)
        return v[index] === Math.max.apply(null, arr);
      });

    //결과값이 이중배열으로 이루어진 id값으로 나오기때문에 [0][0]을 붙혔습니다.
    const mostLikedId = await mostCalculator(getLikes, 1)[0][0];
    const mostCommentsId = await mostCalculator(getComments, 2)[0][0];
    const mostViewedId = await mostCalculator(getViews, 3)[0][0];

    //원하는 값이 최대인 게시글에 아이디를 이용해서 DB안에 값을 찾아줍니다.
    const mostLikedPost = await Post.findOne({
      where: {
        id: mostLikedId,
      },
      attributes: {
        exclude: ["content"],

      ...

    });
    const mostCommentedPost = await Post.findOne({
      where: {
        id: mostCommentsId,
      },
      attributes: {
        exclude: ["content"],

      ...

    });
    const mostViewedPost = await Post.findOne({
      where: {
        id: mostViewedId,
      },
      attributes: {
        exclude: ["content"],

      ...

    });
    //메인페이지에 따로 표시할 해시태그도 잊지않고 가져옵니다.
    const hashtags = await Hashtag.findAll({
      attributes: ["name"],
    });
    res.status(200).json({

    ...

```

---

<br/>

#### 📍 &nbsp; WYSIWYG의 Markdown을 이용한 풍성한 포스팅 구현.

<br/>

#### 📍 &nbsp; 리모콘 또는 헤더를 사용한 간편한 게시물 인터페이스.

<br/>

#### 📍 &nbsp; 게시글안 텍스트로된 키워드들을 정규식으로 파악해 링크로 변환.

```javascript
📁post/[id].tsx

  ...

    useEffect(() => {
    const tagContent = post?.content?.split(/(#[^\s#+^<]+)/g).map((v) => {
      //정규식을 사용해 #name 형식으로 이루어진 키워드 찾아냅니다.
      if (v.match(/(#.*")/g)) {
        //위지글에디터의 결과값이 이 함수에 잘 호환 되지않아 추가적으로 걸러주었습니다.
        return v;
      }
      //유튜브 키워드가 있다면 (위지글에디터가 제공하지 않아서 추가적으로 키워드를 만들었습니다) iframe으로 변환합니다.
      if (v.match(/(#youtube:)/g)) {
        return `<iframe class="youtube" title="YouTube video player" frameborder="0" allow="accelerometer;
        autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
        src="https://www.youtube.com/embed/${v.slice(
          9
        )}"></iframe>`;
      }
      if (v.match(/(#[^\s#+^<]+)/g)) {
        return `<a class="hashtag">${v}</a>`;
      }
      return v;
    });
    const fullContentRemoveComma = post && tagContent?.join("");
    // 나중에 이 값은 html parser를 사용해 게시글에 로드됩니다.
    fullContentRemoveComma && setFullcontent(fullContentRemoveComma);
  }, [post]);

  ...

```

---

<br/>

#### 📍 &nbsp; 댓글 및 좋아요 구현.

<br/>

#### 📍 &nbsp; Infinite Scroll을 구현.

```javascript
📁pages/[category]/index.tsx

  useEffect(() => {
    function onScroll() {
      if (
        //Y축 스크롤 값과 화면에 보이는 페이지 길이
        window.scrollY + document.documentElement.clientHeight >
        //전체 페이지의 길이
        document.documentElement.scrollHeight - 300
      ) {
        if (hasMorePosts && !loadMorePostsLoading && (techPosts || dailyPosts.length > 6)) {
          //포스트가 더 있고 , 포스트를 로딩중이 아니고 , 포스트가 6개 초과이면 값을 가져옵니다.
          //6개씩 값을 가져오는데 6개보다 안된다면 당연히 값을 전부 가져온것이기 때문입니다.
          const LastId =
            (techPosts || dailyPosts) &&
            (techPosts || dailyPosts)[(techPosts || dailyPosts).length - 1].id;
            // 이미 불러온 포스트들(배열)에 마지막값의 아이디를 가져옵니다.
          dispatch({
            type: LOAD_MORE_POSTS_REQUEST,
            data: {
              LastId,
              category,
            },
          });
        }
      }
    }
    window.addEventListener("scroll", onScroll);
    return () => {
      //메모리릭을 방지하기위해 unmount시 removeEventListner
      window.removeEventListener("scroll", onScroll);
    };
  }, [hasMorePosts, loadCategoryPostsLoading, techPosts, dailyPosts]);

```

```javascript
📁server/routes/post.js

router.get("/morepost/:category", async (req, res) => {
  try {
    const category = req.params.category;
    let where = {
      //Last ID 보다 낮은 즉, 이전게시물들을 찾습니다.
      [Op.and]: [{ id: { [Op.lt]: parseInt(req.query.lastId, 10) } }, { category }],
    };
    const morePosts = await Post.findAll({
      //6개씩 불러오고 게시날짜를 내림차로 정렬
      where,
      limit: 6,
      order: [["createdAt", "DESC"]],
      include: [
        //해시태그, 좋아요한 유저가 필요함으로 받아옵니다.
        {
          model: Hashtag,
          attributes: ["name"],
        },
        {
          model: User,
          as: "PostLikers",
          attributes: ["id"],
        },
      ],
    });
    res.status(200).json({ morePosts, category });
  } catch (error) {
    console.error(error);
  }
});

```

```javascript
📁@reducers/post.ts

      ...

      case LOAD_MORE_POSTS_SUCCESS:
        draft.loadMorePostsLoading = false;
        draft.loadMorePostsDone = true;
        //카테고리에 맞는 포스트를 넣어줍니다.
        const moreTechPosts =
          action.data.category === "tech" && draft.techPosts.concat(action.data.morePosts);
        const moreDailyPosts =
          action.data.category === "daily" && draft.dailyPosts.concat(action.data.morePosts);
        draft.techPosts = moreTechPosts;
        draft.dailyPosts = moreDailyPosts;
        //불러온 포스트가 limit값인 6개라는것은 불러온 포스트가 더 있다는 의미입니다.
        //만약 갯수가 딱 맞아서 다음 값이 없다고 해도 그 요청은 0개임으로 false가 됩니다.
        draft.hasMorePosts = action.data.morePosts.length === 6;
        break;

      ...

```

---

<br/>

#### 📍 &nbsp; 일본인을 위한 한국어 강의 페이지 구현.

<br/>

#### 📍 &nbsp; 랜덤 퀴즈 구현.

```javascript
📁class/QuizForm.tsx

  const onClickNextQuiz = useCallback(() => {
    //총 퀴즈 갯수중 하나를 랜덤으로 뽑아옵니다.
    let myRandNum = Math.floor(Math.random() * quizzes.length);
    //만약 랜덤으로 뽑은 값이 현재값이랑 일치한다면...
    if (myRandNum === randomQuiz) {
      //2. 랜덤으로 뽑은값이 마지막값인 상태에서 +1 을 하게 되면 오류가 나게 되기 때문에
      //   첫번째 값으로 변경해서 리턴해줍니다.
      if (myRandNum === quizzes.length - 1) {
        setRandomQuiz(0);
        setViewQuizAnswer(false);
        setQuizAnswer("");
        return;
      }
      //1. 랜덤으로 뽑은 값의 다음값을 리턴합니다.
      setRandomQuiz(myRandNum + 1);
      setViewQuizAnswer(false);
      setQuizAnswer("");
      return;
    }
    setRandomQuiz(myRandNum);
    setViewQuizAnswer(false);
    setQuizAnswer("");
  }, [quizzes.length, randomQuiz, setQuizAnswer]);

  const onClickQuizSubmit = useCallback(() => {
    //퀴즈에 값을 넣지 않았다면 제출버튼이 작동하지 않게 합니다.
    if (quizAnswer === "") {
      message.error("答えを書いてくださいね！");
      return;
    }
    setViewQuizAnswer(true);
  }, [quizAnswer]);

  ...

```

---

<br/>

#### 📍 &nbsp; 포트폴리오 페이지 구현.

<br/>

#### 📍 &nbsp; 그외...

- Redux에 Redux Saga를 추가해 비동기를 구현하고 immer를 적용해 불변성 준수의 불편함을 해소.
- cors 미들웨어를 사용해 기본적인 브라우저-프론트서버-백서버간 cors 문제를 해결.
- Passport.js와 Google Login API를 활용한 로그인, 쿠키와 세션을 사용한 로그인 유지기능 구현.
- bcrypt, node-helmet, https, dot-env, 쿠키의 secret과 expires, Admin 전용 비밀번호, 민감한 정보 클라이언트 취급 X, 예외처리 등으로 웹 보안을 준수하도록 노력했습니다.

<br/>

## Question.

<br/>

> Next.js 사용이유?

SPA의 검색엔진 이슈가 블로그 특성상 치명적이라고 생각되어 SSR의 Next.js를 사용하게 됬습니다. 

<br/>

> Typescript 쓸만한가요?

처음에는 솔직히 귀찮았었는데 정말 잘못된 생각이였다고 생각합니다. 지금은 타입스크립트없인 못사는몸이 되어버렸습니다.

<br/>

> AWS 이용할 만 하나요?

지금같이 꽤나 몸집이 나가는 프로젝트는 AWS+MySQL(or Oracle) 쓸만하다고 생각하는데 간단한 토이프로젝트는 firebase가 더 좋다고 생각합니다. 별개로 몽고DB보단 MySQL을 선호합니다.

<br/>

> Styled-components VS others

저는 개인적으로 Styled-components보다 Emotion이 좋던데 사람마다 다른것같습니다. 하여튼 SCSS는 클래스명때문에 많이 힘들었어서 저는 Styled-components 가 좋습니다.






<br/>

## Retrospective.

<br/>

1. 계획과는 다른 프로젝트가 되었고 차질이 많았습니다. 초반에 체계적인 계획이 능률을 높인다는것을 절실히 깨달았습니다.

2. 스타일시트를 계획적으로 짜지 못했습니다. 또한 변수명에 신경을 잘 써야됨을 느꼈습니다.

3. HTTP 지식과 웹보안쪽이 많이 부족하다고 느꼈고 정보처리기사 시험 및 강의를 통해 보충했습니다.

4. **글으로 적기엔 부족할 만큼 넘었야 할 산이 많았던 무리한 프로젝트였지만 그렇기에 공부가 정말 잘된 프로젝트였다고 생각합니다.**

<br/><br/>

## Thank you for taking your time

<br/>

피드백은 항상 저를 성장시키게 합니다.

궁금한게 있으시면 noah071610@naver.com 으로 언제든지 편하게 연락주세요.

긴글 읽어주셔서 감사합니다.

<br/><br/><br/><br/>
